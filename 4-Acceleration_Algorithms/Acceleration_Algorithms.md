# 第四讲.加速算法(Acceleration Algorithms)
## 空间数据结构(Spatial Data Structures)
空间数据结构是将几何体组合在N维空间中的一系列数据结构，而且我们很容易地将二维和三维的一些概念扩展到高维之中。这些空间数据结构可以用于很多实时渲染相关操作的加速查询中，如场景管理，裁剪算法，相交测试，光线追踪，以及碰撞检测等。  
空间数据结构的组织通常是层次结构的。宽泛的说，即顶层包含它之下的层次，具有嵌套和递归的特点。这种递归可以将复杂度从O(n)提升到O(log n)。这种层次结构的构造开销都比较大，虽然可以在实时过程中进行渐进更新，但是通常需要作为一个预处理的过程来完成。
### 层次包围盒(BVH, Bounding Volume Hierarchies)
层次包围盒方法的核心思想是用体积略大而集合特征简单的包围盒来近似地描述复杂的几何对象，从而只需对包围盒重叠的对象进行进一步的相交测试。此外，通过构造树状结构层次，可以越来越逼近对象的几何模型，直到几乎完全获得对象的几何特征。  
对于三维场景的实时渲染来说，层次包围盒是最常用的，例如，层次包围盒经常用于层次视锥裁剪。场景以层次树结构进行组织，包含一个根节点，一些内部节点，以及一些叶子节点。顶部的节点是根，其无父节点。叶子节点包含需要渲染的实际几何体，并且没有子节点。  
相比之下，内部节点包含指向它子节点的指针。因此，只要根节点不是这棵树唯一的节点，那么它就是一个内部节点。树中的每一个节点，包括叶子节点，都有一个包围体可以将其子树中的所有几何体包围起来，这就是层次包围盒命名的来源，同时，也说明了根节点有一个包含整个场景的包围体。
![](./BVH.png)
左图中有五个物体，每个物体由一个包围的球体封闭起来，其中可以将包围球体归组为一个更大的包围球体。右图所示为层次包围体，可以用来表示左图的物体层次、根节点的包围体包含场景中的所有物体。
### 二元空间分割树/BSP树(Binary Space Partitioning trees)
图形学中的BSP树有两种明显不同的变体存在，分为轴对齐（axis-aligned)和多边形对齐(polygon-aligned)。他们通过一个平面将空间一分为二，然后将几何图形分类到这两个空间中来创建树。这种划分是递归完成的。一个有价值的特性是，如果以某种方式遍历BSP树，则可以从任何角度对树的几何内容进行前后排序，这种排序对于轴对齐来说是近似的排序，但是对于多边形对齐来说是精确的。其中轴对齐的BSP也称为k-d树。
### K-D trees(k-dimensional trees)/Axis-Aligned BSP Trees
轴对齐BSP树可以按照如下方式来创建。首先，将整个场景包围在一个AABB(Axis-Aligned Bounding box，轴对齐包围盒)中,然后以递归的方式将这个包围盒分为若干个更小的盒子。  
现在考虑一下任何递归层次的盒子。选取盒子的一个轴，生成一个与之垂直的平面，将盒子一分为二。有一些方法可以将这个分割平面固定，从而将这个盒子分为完全相同的两个部分，而也有一些方法，允许这个平面在位置上有一些变化。与分割平面相交的物体，要么存储在这个层次上，成为两个子集中的一员，要么被这个平面分割为两个不同的物体。经过这个过程，直到满足某个标准才终止这个分割过程。而这个标准，通常是用户定义的树最大深度，或者是盒子里面所有包含的几何图元数量，需低于用户定义的某个值。  

分割平面的轴线和位置对提高效率至关重要。一种分割包围盒的方法就是轴进行循环。即在根节点，沿着x轴对盒子进行分割，然后再沿着y轴对子盒子进行分割，最后沿着z轴对其孙盒子进行分割。这样，就完成了一个循环周期。使用这种分割策略的BSP树常被称为k-d树，而另一种常见的策略是找到盒子的最长边，沿着这条边的方向对盒子进行分割。
![](./k-d%20tree.png)
值得一提的是，从前到后的粗排序是轴对齐BSP树的一种应用示例，这种方法对于遮挡剔除算法非常有用。而在视点的另一侧进行遍历，可以得到从后向前的粗排序，这对于透明排序非常有用。且还可以用来测试射线和场景的几何相交的问题，只需将视点位置换为射线原点即可，另外还可以用于视锥裁剪。

### 多边形对齐BSP树(Polygon-aligned BSP tree)
多边形对齐BSP树是将多边形作为分割物，对空间进行平分。也就是说，在根节点处，选取一个多边形，用这个多边形所在平面将场景中剩余多边形分为两组。对于与分割平面相交的多边形来说，沿着其中的交线将这个多边形分成两部分。然后，在分割平面的每半个空间中，选取另外一个多边形作为分割物，只对这个分割物所在平面的多边形进行继续分割，知道所有的多边形都在BSP树中为止。  

需要注意的是，多边形对齐的BSP树的创建是一个非常耗时的过程，这些树通常只计算一次，可以存储起来进行重用。  
下图是多边形对齐BSP的图示。
![](./Ploygon-aligned%20BSP%20tree.png)
左图中，多边形分别用A~G表示。首先，用多边形A对空间进行分割，生成的两个半空间分别由多边形B和C分割，由B形成的分割平面与左下角的多边形相交，将其分割为多边形D和E。最后形成的BSP树如右图所示。  

因为完全不平衡树的效率非常低，所以多边形对齐BSP树分割时最好是形成平衡树，即每个叶子节点的深度相差绝对值不超过1。

多边形对齐BSP树的一个典型性质就是对于一个给定的视点来说，可以对该结构按照从后向前(或者从前向后)的顺序进行严格遍历，而轴对齐BSP只能给出粗略的排序顺序。所以基于多边形对齐BSP树的此性质，建立了严格的前后顺序，可以配合画家算法来绘制整个场景，而无须z buffer。  

多边形对齐BSP树的其他应用也包括相交测试和碰撞检测等。

### 八叉树(Octrees)
### 场景图(Scene Graphs)
## 裁剪技术(Culling Techniques)
### 背面裁剪(Backface Culling)
### 视锥裁剪(View Frustum Culling)
### 入口裁剪(Portal Culling)
### 细节和小三角形裁剪(Detail and Small Triangle Culling)
### 遮挡裁剪(Occlusion Culling)
## LOD(Level of Detail)
### LOD切换(LOD Switching)
### LOD选取(LOD Selection)
## 大型场景渲染(Rendering Large Scenes)
### 虚拟纹理和流(Virtual Texturing and Streaming)